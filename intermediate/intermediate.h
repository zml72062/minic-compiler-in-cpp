#ifndef INTERMEDIATE_H
#define INTERMEDIATE_H

#include <string>
#include <vector>
#include <map>
#include "../parse/symbols.h"

/************************************************************
 *      Definition of the intermediate representation.      *
 ************************************************************/

/** For the intermediate representation, we model our memory
 *  system as
 *      a) Main Memory, as an infinite byte array.
 *      b) infinitely many Registers, each with size INT_SIZE.
 *  We also assume the size of address into the Main Memory
 *  has size PTR_SIZE, and PTR_SIZE == INT_SIZE.
 */
#define INT_SIZE 4
#define PTR_SIZE 4

#define PLACEHOLDER 0

/**
 *  In the following, we always store user-defined variables
 *  (i.e. variables that have a symbol table entry) 
 *  in Main Memory (by using ALLOC instruction).
 *  
 *  Temporary variables (generated by compiler) are always
 *  stored in Registers.
*/

/**
 *  IRMOV dest, loperand
 *      Move the immediate 'loperand' to register 'dest'.
 */
#define INSTR_IRMOV 0
/**
 *  RRMOV dest, loperand
 *      Move the value stored in register 'loperand' to register 'dest'.
 */
#define INSTR_RRMOV 1
/**
 *  RMMOV dest, loperand
 *      Move the value stored in register 'loperand' to the address stored 
 *      in 'dest',
 */
#define INSTR_RMMOV 2
/**
 *  MRMOV dest, loperand
 *      Move the value stored in the address stored in 'loperand' to register 
 *      'dest'.
 */
#define INSTR_MRMOV 3
/**
 *  ALLOC dest, loperand
 *      Allocate a memory space of 'loperand' bytes to the address stored in
 *      'dest'.
 */
#define INSTR_ALLOC 4
/**
 *  NEG dest, loperand
 *  NOT dest, loperand
 *  ADD dest, loperand, roperand
 *  SUB dest, loperand, roperand
 *  MUL dest, loperand, roperand
 *  DIV dest, loperand, roperand
 *  MOD dest, loperand, roperand
 *  GT  dest, loperand, roperand
 *  GEQ dest, loperand, roperand
 *  LT  dest, loperand, roperand
 *  LEQ dest, loperand, roperand
 *  EQ  dest, loperand, roperand
 *  NEQ dest, loperand, roperand
 *      Instructions for unary and binary operations. Operate on values stored
 *      in registers 'loperand' and (optionally) 'roperand', and store the result 
 *      to register 'dest'.
 */
#define INSTR_NEG 5
#define INSTR_NOT 6
#define INSTR_ADD 7
#define INSTR_SUB 8
#define INSTR_MUL 9
#define INSTR_DIV 10
#define INSTR_MOD 11
#define INSTR_GT 12
#define INSTR_GEQ 13
#define INSTR_LT 14
#define INSTR_LEQ 15
#define INSTR_EQ 16
#define INSTR_NEQ 17
/**
 *  JMP roperand
 *      Jump to the instruction with label 'roperand'.
 */
#define INSTR_JMP 18
/**
 *  JE  loperand, roperand
 *  JNE loperand, roperand
 *      Jump to the instruction with label 'roperand' if 'loperand == 0' or
 *      'loperand != 0', where 'loperand' is a register.
 */
#define INSTR_JE 19
#define INSTR_JNE 20
/**
 *  ARG loperand, roperand
 *      Move the value stored in 'roperand' to the register for the 'loperand'-th
 *      argument.
 */
#define INSTR_ARG 21
/**
 *  LARG loperand, roperand
 *      Move the value stored in the register for the 'roperand'-th argument to
 *      register 'loperand'.
 */
#define INSTR_LARG 22
/**
 *  CALL dest, loperand, roperand
 *      Call the function whose label is 'loperand' with 'roperand' arguments, and
 *      store the return value at 'dest'.
 */
#define INSTR_CALL 23
/**
 *  RET loperand
 *      Move the value stored in 'loperand' to the return value register and 
 *      return. If 'loperand == 0', then no return value.
 */
#define INSTR_RET 24
/**
 *  GLOB loperand
 *      Declare that the immediate 'loperand' is an address for global symbol,
 *      whose memory allocation is handled by operating system.
 */
#define INSTR_GLOB 25

/************************************************************
 *    End definition of the intermediate representation.    *
 ************************************************************/

extern SymbolTable* symbol_table;

struct IntermediateCode
{
    std::size_t label;
    std::size_t loperand;
    std::size_t roperand;
    std::size_t dest;
    std::size_t instr;
    IntermediateCode(std::size_t _instr, std::size_t _dest, std::size_t _loperand, std::size_t _roperand);
    IntermediateCode(std::size_t _instr, std::size_t _dest, std::size_t _loperand, std::size_t _roperand, std::size_t& _label);
    std::string to_str();
};

struct IntermediateCodeGenerator
{
private:
    std::size_t next_variable_label;
    std::size_t next_statement_label;
    std::size_t next_global_symbol_label;
    std::size_t statement_label;
    std::size_t label_if_break;
    std::size_t label_if_continue;
    std::vector<IntermediateCode*> code;
    std::size_t generate_addr();
    std::size_t generate_global_addr();
    std::size_t generate_label();
    std::size_t generate_code_for_exp(Symbol* symbol);
    std::size_t generate_code_for_exp_as_rval(Symbol* symbol);
    void generate_code_for_block_and_statement(Symbol* symbol);
public:
    int error;
    IntermediateCodeGenerator();
    ~IntermediateCodeGenerator();
    void generate_code();
    void print_code();
};


#endif